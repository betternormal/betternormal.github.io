# HTML

무언가를 공부할 땐 자주 사용되는것 먼저 공부하자

![Untitled (10)](https://user-images.githubusercontent.com/64571546/104970331-6d14b080-5a2e-11eb-9766-64ec6d257190.png)


## HTML작성시 의미있는 태그를 쓰는것이 중요한이유

무언가를 찾을 때 우리는 검색포털에 검색한다. 그리고 보통 검색결과의 3페이지 이상 찾아보지 않는다. 오늘날 현대사회에서 검색엔진이 차지하는 위상은 굉장히 크기 때문에 검색엔진에 노출되지않는것은 존재하지 않는것이나 마찬가지이다.

검색엔진은 검색어가 들어오면 전세계의 해당되는 웹페이지를 내려받아 그 웹페이지에 담긴 HTML코드를 분석한다.  그리고 코드의 내용(태그)에 근거해서 제목, 내용, 등을  정리정돈한다. 이 때 정보로서의 가치가 더 높은 페이지가 검색순위의 상단에 올라가게 된다. 그래서 HTML의 의미에 맞게 정확하게 사용하는것은 비즈니스 측면에서 중요한 문제이다.

화려한것보다 중요한건 웹이 가지고있는 본래의 의미나 정보를 탄탄히 하는것이다. 

경우에따라서는 이미지로 글을 쓰는 경우가 있는데 이런경우 검색엔진에서는 존재하지 않는 글이 된다. 

또다른 중요한이유는 웹의 핵심적인 철학인 '접근성'이다. 웹은 모든 운영체제에서 동작하고 웹의 소스코드는 누구나 볼 수 있고, 저작권이 없는 순수한 공공재이다. 이것을 개방성 또는 접근성이라고 한다. 웹이 중요하게 생각하는 접근성중 하나는 신체적인 장애가 있는 분들도 정보로부터 소외당하지 않도록 노력해야 한다는 것이다. 예를들어 시각장애가 있는분들은 텍스트를 이용해 소리로 변환하는데, 예쁘게 만들고싶어서 이미지로 문자를 그리면 시각장애가 있는분들에게는 읽을수 없는 페이지가 되어버린다.  가장중요한 첫걸음은 HTML의 태그를 정확히 알고 의미에 맞게 사용하는 것이다. HTML은 비즈니스적 측면뿐아니라 휴머니즘 측면에서도 중요한 기술이다.

### **줄바꿈 &lt;br&gt; vs &lt;p&gt;**

- 둘의 결과는 같지만 사용가치가 다르다.
- <p>태그는 좀더 정보로서의 가치가 있다. 단락이 존재한다는것을 의미론적으로 표현할 수 있지만 <br>태그는 단지 줄바꿈일뿐이다.
- <br> 태그는 줄바꿈을 여러번 사용해 간격을 조절하기쉽지많 <p>태그는 정해진 여백만큼 떨어지므로 자유도가 떨어진다. 하지만 이를위해 css를 사용할 수 있다. **결론적으로 의미있는 태그를 사용하면서 css로 정교하게 제어하는것이 좋다.**

### Block, Inline Elements

태그들은 태그의 성격과 일반적인 쓰임에 따라 화면전체를 쓰는것이 편한것과 자신의 크기만큼 부피를 갖는게 편한것이 있기때문에 Block level엘리먼트와 Inline level 엘리먼트로 나뉘게된다. 이는 단지 기본값일뿐 display: 속성으로 제어할 수 있다.



# CSS

(Cascading Style Sheets)

웹페이지를 사람에 비유해본다면, 마크업언어(HTML)은 몸의 구조(뼈, 근육)이고 CSS는 옷과 신발과 같이 외적으로 꾸며주는 역할을 한다.

### CSS 인코딩 방식 선언

@charset은 문자 인코딩 방식을 지정한다. ⇒ 기계(컴퓨터, 브라우저)가 잘 이해할 수 있도록 알려줌

자바스크립트 파일은 HTML 문서에 있는 <script>태그에 속성을 적지만, CSS파일은 외부 파일에 직접 적는다.

```jsx
@charset "utf-8";
```

### 외부 스타일 시트로 작업

- html에는 html코드만 추가하고 css코드는 외부 스타일 시트로 작업한다.
- link 태그로 html문서와 css문서를 연결함으로써 재사용성이 높아졌다.

```jsx
// <link>를 통한 외부 스타일 시트 사용
<head>
	<link rel="stylesheet" href="./main.css">
</head>
```

### css영향력

태그선택자 < 클래스선택자 < ID선택자(중복이라면 제일마지막에오는 선택자)

### id또는 태그 선택자가 아닌 class 선택자 사용

- id선택자는 유니크하기때문에 중복으로 사용할 수 없다.
- div, span과 같은 태그 선택자를 사용하면 한 태그에는 한 스타일밖에 줄 수 없다.
- class는 중복으로 사용할 수 있다.

### 반응형CSS - 미디어쿼리

@media(min-width: 800px){} 

화면의 크기가 800보다 크다는것은 화면크기의 최소값이 800px이라는 것과 같다.

출처: 생활코딩

# **레이아웃: 화면을 나누는 방법**

## **HTML 구성**

기본적으로 콘텐츠의 흐름은 좌에서 우로, 위에서 아래로 흐른다. 먼저 수직으로 분할하고, 수직으로 분할된 div에서 height 속성을 이용해 수평 분할을 한다.

![Untitled](https://user-images.githubusercontent.com/64571546/105645021-6aa5d100-5edc-11eb-820e-7c853a815e3b.png)


![Untitled (1)](https://user-images.githubusercontent.com/64571546/105645026-7396a280-5edc-11eb-9e80-23564634002b.png)


```jsx
<div id="container">
	<div class="col w10">
		<div class="icon">아이콘 1</div>
		<div class="icon">아이콘 2</div>
		<div class="icon">아이콘 3</div>
	</div>
	<div class="col w20">
		<div class="row h40">영역1</div>
		<div class="row h40">영역2</div>
		<div class="row h20">영역3</div>
	</div><div class="col w70">
		<div class="row h80">영역4</div>
		<div class="row h20">영역5</div>
	</div>
</div>
```

```
.w70 { width: 70%; }
.h40 { height: 40%; }
```

위와 같이 클래스 이름과 구현을 1:1로 일치시키는 CSS 작성 기법을 [Atomic CSS 방법론](https://www.sitepoint.com/css-architecture-block-element-modifier-bem-atomic-css/)🔗 이라고 한다.

## **레이아웃 리셋**

HTML의 문서가 갖는 기본 스타일이 레이아웃을 잡는 데 방해가 될 수 있다. 

- 박스의 시작을 정확히 (0,0)의 위치에서 시작하고 싶은데, `<body>` 태그가 기본적으로 약간의 여백을 갖고 있습니다.
- width, height 계산이 여백을 포함하지 않아서 계산하기 힘듭니다. ( `box-sizing` )
- 브라우저마다 여백이나 글꼴이 조금씩 다르다.

 위에 언급한 문제를 해결할 몇 줄의 코드를 적용시키기만 하면 된다.

```
* {
  box-sizing: border-box;
}

body {
  margin: 0;
  padding: 0;
}
```

## **Flexbox로 레이아웃 잡기**

flexbox 레이아웃은, 말 그대로 박스를 유연하게 늘리고 줄이는 방법을 토대로 레이아웃을 잡는 방법이다. 

### **Flex 코드 분석하기**

flex는 부모 박스에 `display: flex`를 적용해줌으로, 자식 박스의 방향과 크기를 결정한다.
기본적으로, flex가 적용된 부모 박스의 자식 박스는 왼쪽으로 차례대로 붙게 됩니다.

```jsx
<div id="outer">
	<div class="box">box1</div>
	<div class="box">box2</div>
	<div class="box">box3</div>
</div>
```

```
#outer {
  display: flex;
  border: 1px dotted red;
  padding: 10px;
}

.box {
  border: 1px solid green;
  padding: 10px;
}

```

![Untitled (2)](https://user-images.githubusercontent.com/64571546/105645037-84dfaf00-5edc-11eb-98b7-ee96829a4f8a.png)


[codepen에서 보기](https://codepen.io/igotoweb/pen/ZEORQXL)

### **방향 (flex-direction)**

기본적으로 flexbox는 박스가 수직으로 분할되지만, 수평으로도 분할할 수 있다. 

- row (기본값)
- column

### **Must know concepts: grow(팽창 지수), shrink(수축 지수), basis(기본 크기)**

자식 박스에 어떠한 속성도 주지 않으면, 그저 오른쪽으로 컨텐츠 크기만큼 배치됩니다. 이 때의 자식 박스의 flex 속성 기본값은 다음과 같습니다.
(flex 속성은 부모에 적용하는 것이 아닌, 자식 박스에 적용한다.)

```
flex: 0 1 auto;
```

Flexbox는 **기본 크기를 바탕으로 필요에 따라 늘릴 수 있다** 라는 컨셉이다.

flex 속성은 자식 박스를 어떤 식으로 늘릴지를 결정한다. 각각의 값이 의미하는 것은 다음과 같습니다.

```jsx
flex-grow: 0;
flex-shrink: 1;
flex-basis: auto;
```

```jsx
flex: <grow> <shrink> <basis>
```

grow, shrink는 단위가 없고, 비례하는 값이다. 박스를 여러개로 나누었을 때, 각 자식 박스가 갖는 grow값의 총 합이 n이라고 한다면. 이 때의 1은 1/n의 크기를 의미한다, 2는 2/n의 크기를 의미한다.

## — Test —

```jsx
<div id="outer">
	<div class="box target">.box.target</div>
	<div class="box">.box</div>
	<div class="box">.box</div>
</div>
```

### **grow: 이 박스는 얼마나 늘어날 수 있나요?**

grow를 1로 바꿔본다. 해당 박스는 가로의 남은 영역 전부만큼 늘어난다. (총 grow값의 합은 1+0+0이므로, .target은 1/1 = 100%이여야 하지만, .box 안에 이미 콘텐츠가 존재하므로 콘텐츠가 담긴 크기는 보장합니다)

```
.target {
  flex: 1 1 auto;
}
```

![Untitled (3)](https://user-images.githubusercontent.com/64571546/105645049-8b6e2680-5edc-11eb-99b7-d8c9f4ec3f67.png)


[codepen에서 보기](https://codepen.io/igotoweb/pen/pobKgdb)

box 클래스의 flex 속성에 grow를 1로 주면, 모든 박스가 늘어나려고(grow) 하므로, 결과적으로 동일한 비율로 박스가 늘어나게 된다. (총 grow 값 1+1+1, 각 박스는 1/3씩 크기를 가짐)

```
.box {
  flex: 1 1 auto;
}
```

![Untitled (4)](https://user-images.githubusercontent.com/64571546/105645053-93c66180-5edc-11eb-9276-321ecfa69805.png)


[codepen에서 보기](https://codepen.io/igotoweb/pen/mdEKVqo)

**grow 값은 비율을 의미한다.**

```
.box {
  flex: 1 1 auto;
}

.target {
  flex: 2 1 auto; /* 자식 박스가 총 세개인데, target만 2의 비율을 가지므로, 결과적으로 가로의 50%를 차지하게 됨 */
}
```

- .target의 grow 속성이 2, .box의 grow 속성이 1일 경우, `2+1+1`로 박스가 만들어지므로, 속성 1은 1/4의 크기를 가짐

![Untitled (5)](https://user-images.githubusercontent.com/64571546/105645058-9a54d900-5edc-11eb-88b2-3f8f77125924.png)


[codepen에서 보기](https://codepen.io/igotoweb/pen/PozaZeM)

### **shrink: 이 박스는 얼마나 줄어들 수 있나요?**

shrink는 grow와 반대로, 차지하는 비율만큼 박스 크기가 작아지게 만든다. shrink는 width나 basis에 따른 비율이어서 실제 크기를 예측하기 어렵다.  그래서 비율로 레이아웃을 지정할 경우 grow를 주로 사용합니다.  shrink는 기본값인 1로 두어도 무방하다.

### **basis: 이 박스의 기본 크기는 몇인가요?**

박스가 grow나 shrink에 의해 늘어나거나 줄어들기 전 갖게 되는 기본 크기를 의미한다. 

grow가 0일 때, basis 크기를 지정하면 그 크기는 보장된다.

```jsx
<div id="outer">
	<div class="left">메뉴</div>
	<div class="right">본문</div>
</div>
```

```
.left {
  flex: 0 1 100px; /* grow를 0으로 설정해줘야 100px 이상으로 늘어나지 않습니다. */
}

.right {
  flex: 1 1 auto; /* 우측 박스는 grow를 1로 설정해 나머지 공간을 채워줍시다 */
}
```

![Untitled (6)](https://user-images.githubusercontent.com/64571546/105645061-a0e35080-5edc-11eb-8a52-b89baf843cb6.png)


[codepen에서 보기](https://codepen.io/igotoweb/pen/qBNKbMy)

- `width`와 `flex-basis`를 동시에 적용하면, `flex-basis`가 우선된다.
- 안쪽 박스의 콘텐츠가 넘칠 경우, `width`가 정확한 크기를 보장하지 않는다.
- 안쪽 박스의 콘텐츠가 넘치는 경우를 대비해, `width` 대신 `max-width`를 쓸 수 있다. (`flex-basis`를 사용하지 않을 경우)

### **컨텐츠 수평 정렬 (justify-content)**

바깥 박스에 justify-content 속성을 이용하면, 안쪽 박스의 수평 정렬을 지정할 수 있다.

- flex-start
- flex-end
- center
- space-between

### **컨텐츠 수직 정렬 (align-items)**

바깥 박스에 align-items 속성을 이용하면, 안쪽 박스의 수직 정렬을 지정할 수 있습니다.

- flex-start
- flex-end
- center
- stretch
