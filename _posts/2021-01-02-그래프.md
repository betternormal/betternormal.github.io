그래프, 트리, 이진탐색트리는 모두 그래프의 형태를 가지는 자료구조이다.

# 1. Graph

그래프는 노드(Node), 노드와 노드를 연결하는 간선으로 구성된다. 그래프는 무방향(undirected) 일수도, 방향성((directed))을 가질 수도 있다. 무방향일 경우 간선에 의해 연결된 2개의 노드가 대칭일 수 있다는 의미이고 방향성이 있는경우는 비대칭관계임을 의미한다.

![Untitled (13)](https://user-images.githubusercontent.com/64571546/103449509-6b3bb500-4cec-11eb-8c7e-4bf489606ab3.png)


[Graph](https://en.wikipedia.org/wiki/Graph_(abstract_data_type))

## Methods

- `addNode(node)` - 그래프에 노드를 추가합니다.
- `addEdge(fromNode, toNode)` - fromNode와 toNode 사이의 간선을 추가합니다.
- `removeNode(node)` - 그래프에서 노드를 삭제합니다.
- `removeEdge(fromNode, toNode)` - fromNode와 toNode 사이의 간선을 삭제합니다.
- `hasEdge(fromNode, toNode)` - fromNode와 toNode 사이의 간선 존재 여부를 반환합니다.
- `contains(node)` - 그래프에 해당 노드가 존재하는지 여부를 반환합니다.

```jsx

/* 무방향 그래프(Undirected Graph), 
인접 리스트 (Adjacency List) 방식으로 구현*/

class Graph {
  constructor() {
    this.nodes = {};
  }

  addNode(node) {
    this.nodes[node] = this.nodes[node] || [];
  }

  contains(node) {
    return !!this.nodes[node];
  }

  removeNode(node) {
    if (this.contains(node)) {
      for (let i = 0; i < this.nodes[node].length; i += 1) {
        this.removeEdge(this.nodes[node][i], node);
      }
      delete this.nodes[node];
    }
  }

  hasEdge(fromNode, toNode) {
    if (!this.contains(fromNode)) {
      return false;
    }
    return !!this.nodes[fromNode].includes(toNode);
  }

  addEdge(fromNode, toNode) {
    if (!this.contains(fromNode) || !this.contains(toNode)) {
      return;
    }

    // Add an edge to each node pointing to the other
    if (!this.hasEdge(fromNode, toNode)) {
      this.nodes[fromNode].push(toNode);
    }

    if (!this.hasEdge(toNode, fromNode)) {
      this.nodes[toNode].push(fromNode);
    }
  }

  removeEdge(fromNode, toNode) {
    if (!this.contains(fromNode) || !this.contains(toNode)) {
      return;
    }

    // Remove edges from each node's edge list
    if (this.hasEdge(fromNode, toNode)) {
      const index1 = this.nodes[fromNode].indexOf(toNode);
      this.nodes[fromNode].splice(index1, 1);
    }

    if (this.hasEdge(toNode, fromNode)) {
      const index2 = this.nodes[toNode].indexOf(fromNode);
      this.nodes[toNode].splice(index2, 1);
    }
  }
}

module.exports = Graph;
```

### **질문**

- 진입 차수, 진출 차수가 무엇입니까?

    정점에 부속되어 있는 간선의 수를 차수(Degree)라 한다. 방향그래프에서는 부속된 간선의 방향에 따라 진입차수와 진출차수가 생긴다. 정점을 머리로 하는 간선의 수는 진입차수(in-degree)이고, 정점을 꼬리고 하는 간선의 수는 진출차수(out-degree) 이다.

- 그래프 구현 방식 중 인접 행렬 방식과 인접 리스트 방식의 차이는 무엇입니까?

    ### 1) 인접 행렬 방식

    인접행렬은 그래프의 연결관계를 이차원배열로 나타내는 방식이다. 

    ```jsx
    adj[i][j] : 노드 i에서 노드 j로 가는 간선이 있으면 1, 아니면 0
    ```

    방향성(directed)

    <img width="833" alt="_2021-01-02__10 41 26" src="https://user-images.githubusercontent.com/64571546/103449494-41828e00-4cec-11eb-8b93-5266434915f1.png">

    무방향(undirected)

    <img width="825" alt="_2021-01-02__10 44 34" src="https://user-images.githubusercontent.com/64571546/103449496-447d7e80-4cec-11eb-9ff7-6e6833e975e8.png">

    **장단점**

    - 장점 : 구현이 쉽다.  연결확인시 adj[i][j]가 1인지 0인지만 확인하면 되기 때문에 O(1)의 시간복잡도가 걸린다.
    - 단점 : 연결된 모든 노드에 방문하고싶은경우 O(n)의 시간이 걸리게된다.

    ### 2) 인접 리스트 방식

    인접리스트는 그래프의 연결관계를 vector의 배열로 나타내는 방식이다.

    ```jsx
    adj[i] : 노드 i에 연결된 노드들을 원소로 갖는 vector
    ```

    방향성(directed)

    <img width="845" alt="_2021-01-02__10 49 24" src="https://user-images.githubusercontent.com/64571546/103449497-46dfd880-4cec-11eb-9c76-5d16bd03f615.png">

    무방향(undirected)

    <img width="840" alt="_2021-01-02__10 51 21" src="https://user-images.githubusercontent.com/64571546/103449529-b0f87d80-4cec-11eb-8c47-102460af73ed.png">

    adj[1]에 있는 세 노드의 순서는 의미가 없다. 

    **장단점**

    - 장점 : 인접리스트는 인접행렬과 달리 실제로 연결된 노드들에 대한 정보만 저장하기 때문에 모든 벡터들의 개수가 간선의 개수와 같다. 즉, 간선의 개수에 비례하는 메모리만 차지한다. 노드에 연결된 간선을 확인할때  시간복잡도는 O(간선의 개수)이다.
    - 단점 : 노드i와 j가 연결되어있는지 확인 할 때 시간복잡도가 O(n)이 걸린다.
