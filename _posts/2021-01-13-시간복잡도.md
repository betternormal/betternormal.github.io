---
layout: post
author: "praconfi"
tags: DataStructure CS
title: "시간복잡도"
---

> 중요한 것은 자신이 작성하는 알고리즘의 시간복잡도에 대해 고민 할 수 있는 자세이다. 또한 작성시 이를 스스로 선택할 수 있어야 한다.
알고리즘을 작성 할 때 시간복잡도를 고민함과 동시에 적당한 데이터 구조를 선택하는 것도 개발자의 중요한 역량중 하나이다. 

Big-O

Big-O notation is a way of converting the overall steps of an algorithm into algebraic terms, then excluding lower order constants and coefficients that don’t have that big an impact on the overall complexity of the problem.

![Untitled (7)](https://user-images.githubusercontent.com/64571546/104383844-da7a9a00-5573-11eb-9dcc-0233f0da48f6.png)


### O(1) constant time

입력값 n이 주어졌을 때, 알고리즘이 문제를 해결하는데 오직 한단계만 거친다.

```jsx
var dummyArray = [1, 2, 3, 4];
dummyArray.pop() // 4
```

### O(log N) log time

입력값 n이 주어졌을 때, 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어든다.

```
function FindItemBinarySearch(items, match) {
      var low = 0,
          high = items.length -1;

      while (low <= high) {
          mid = parseInt((low + high) / 2);

           current = items[mid];

          if (current > match) {
             high = mid - 1;
           } else if (current < match) {
              low = mid + 1;
            } else {
              return mid;
           }   
      }       

      return -1;
  }
```

### O(n) linear time

문제를 해결하기 위한 단계의 수와 입력값 n이 1:1 관계를 갖는다.

```
Array.prototype.indexOf = function (element){
  for (var x = 0, count = this.length; x < count; x++){
    if(this[x] === element){
      return x;
    }
  }
  return -1;
};
```

### O(n^2) quadratic time

문제를 해결하기 위한 단계의 수는 입력값 n의 제곱이다.

```
const buildMatrix = (n) => {
  var matrix = new Array(n);
  for (var i = 0; i < n; i++) {
      var cols = new Array(n);
      matrix[i] = cols;
      for (var j = 0; j < n; j++) {
        cols[j] = j
      }
  }
  return matrix
}
```

### O(c^n) expotential time

문제를 해결하기 위한 단계의 수는 주어진 상수값 c의 n제곱이다.

```
function fibonacci(num) {
	var answer = 0;
	if( num <= 1 ) {
		return num;
	}
	else if( num > 1 ) {
		answer = fibonacci(num-1) + fibonacci(num-2);
	}
	return answer;
}
```

![Untitled (8)](https://user-images.githubusercontent.com/64571546/104383900-efefc400-5573-11eb-9931-707a9ea914b4.png)


![Untitled (9)](https://user-images.githubusercontent.com/64571546/104383931-fda54980-5573-11eb-84bb-0ae4fe98cb8c.png)

# Array
- Look up(특정위치의 데이터 가져오기) : O(1) 배열의 저장소에는 index가 있기때문에 바로 접근할 수 있다.
- Assign(특정위치에 데이터 넣기) : O(1) 배열의 저장소에는 index가 있기때문에 바로 접근할 수 있다.
- Insert(특정위치에 데이터 추가) : O(n) 중간에 값을 끼워넣는 경우에는 밀리는 자료들의 index를 새로 한칸씩 조정해줘야 한다. 몇개 안될 수도 있지만 시간복잡도는 최악의 경우를 가정한다.
- Remove(특정위치의 데이터 제거) : O(n) 제거된 위치를 채워줘야 하기때문에 채워지는 자료들의 index를 새로 한칸씩 조정해줘야 한다. 몇개 안될 수도 있지만 시간복잡도는 최악의 경우를 가정한다.
- Find (특정 value값을 찾는다.) : O(n) 인덱스값 각각 들어가서 value값을 확인해줘야 하기 때문에 일일이 다 확인해야 한다.

# Linked List
> array와 비슷해보이지만 다르다.
각각 요소는 자기자신의 value값과 다음 요소에 대한 정보 2가지만 가지고 있다.
그렇기때문에 시작점인 head를 꼭 알고있어야 한다.

- Look up(특정위치의 데이터 가져오기): O(n) 몇번째에있는 데이터값을 확인해야하는데 링크드 리스트는 index값이 없다. 만약 n번째 인덱스에 접근하려면 n번 이동해야 한다.
- Assign(특정위치에 데이터 넣기) : O(n) 특정위치까지 이동하게되면서 최대로는 n번 이동해야 한다.
- Insert(특정위치에 데이터 추가) : O(1) 배열과는 다르게 밀리는 값들이 index가 없기때문에 현재 추가하는작업만 수행된다. 2번의 수행(이전에서 이어지기, 이후로 잇기)만 필요하다.
- Remove(특정위치의 데이터 제거) : O(n) 중간노드를 지울때 2가지 작업이 필요하다. 내가 가르키고있는 다음노드와의 연결끊기, 이전노드와 다음노드를 나빼고 이어주기
2가지작업이지만 2번째 작업이 어렵다. 링크드리스트는 다음노드에 대한 정보만 있기때문에 나를 가르키는 노드를 찾으려면 최대 n번의 수행이 필요하다.
- Find (특정 value값을 찾는다.) : O(n) head부터 tail까지 value값이 내가 찾는값인지 확인해봐야 하기 때문에 최대 n번 수행하게 된다.

# Trees
> 트리는 내값과 부모? 자식에 대한 정보를 가지고 있다.

- Find (특정 value값을 찾는다.) : O(n) 모든자식노드들을 내려가서 확인해봐야 한다.

# Binary Serach Trees
- Find (특정 value값을 찾는다.) : O(log n) 바이너리 서치트리는 특수한조건(왼쪽은 작고 오른족은 크다)이 있기 때문에 검색할때 검색횟수가 현저히 줄어든다.
ref.

[Looking For The Logic Behind Logarithms](https://medium.com/basecs/looking-for-the-logic-behind-logarithms-9e79d7666dda)

[Understanding Time Complexity and its Importance in Technology](https://medium.com/@abdurrafeymasood/understanding-time-complexity-and-its-importance-in-technology-8279f72d1c6a)

[8 time complexities that every programmer should know](https://adrianmejia.com/most-popular-algorithms-time-complexity-every-programmer-should-know-free-online-tutorial-course/)

[(번역) 알고리즘 쉽게 이해하기 : 시간 복잡도와 Big-O 표기](https://joshuajangblog.wordpress.com/2016/09/21/time_complexity_big_o_in_easy_explanation/)
