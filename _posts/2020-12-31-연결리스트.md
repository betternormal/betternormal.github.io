연결리스트는 배열처럼 여러 데이터를 선형적으로 담을 수 있다.

하지만 배열과는 어떤 부분이 다른지도 알아봐야 한다.

해시테이블은 어렵고 다른성격을 가지는 자료구조이지만 장점이 많다.

![Untitled (7)](https://user-images.githubusercontent.com/64571546/103385080-56b8ba80-4b3c-11eb-9966-c929d23fb98f.png)

# 1. 연결리스트

앞에서 다룬 스택이나 큐를 생각해보면 자료구조 내의 데이터가 다른 데이터와 관계성을 가지고 있지는 않았다. 하지만 연결리스트는 다르다. 이름에서도 유추할 수 있듯, 연결리스트의 핵심은 연결(Link)다.

연결리스트는 크기가 동적인 자료구조로 자료구조를 구성하는 요소(노드)의 연결로 이루어져있다. 연결리스트의 어떠한 임의의 지점에 데이터의 추가와 삭제를 할 경우 O(1) (상수시간)의 시간복잡도를 갖는다. 추가와 삭제에 대해 O(n)의 시간복잡도를 갖는 배열과 다르다.

다만 이 추가와 삭제속도에 대한 대가로, 연결리스트의 각 노드는 인덱스를 갖지 않는다. 그래서 어떤 특정데이터를 연결리스트에서 검색하고자 하는 경우 처음부터 전체 연결리스트를 훓어야 하면 이는 O(n)의 시작복잡도를 필요로 한다.

사용예시 

음악을 들을 때 보통 플레이리스트로 듣고싶은 음악을 특정 순서대로 듣는다. 셔플로 섞어서 들을 수도 있지만 항상 한곡씩 듣게 되어있다. 그리고 노래 한곡이 끝나면 다음곡으로 넘어간다. 

연결리스트도 마찬가지로 하나씩 순환된다. 다만 곡 대신 '노드'를 활용한다.

![Untitled (8)](https://user-images.githubusercontent.com/64571546/103385088-5c160500-4b3c-11eb-93ea-76f2018abfd2.png)

구조: 연결리스트에 속한 각 엘리먼트들을 노드(node)라고 부르는데 하나의 노드는 데이터파트(Data Part)와 넥스트파트(Next Part) 두부분으로 이루어져있다.데이터파트에는 값이 저장되어있고, 넥스트 파트는 다음 노드를 가리키고 연결하는 역할을 한다.

![_2020-12-23__7 35 46](https://user-images.githubusercontent.com/64571546/103385092-5fa98c00-4b3c-11eb-88c9-a31b02051792.png)

[Linked List](https://en.wikipedia.org/wiki/Linked_list)

- `addToTail(value)` - 주어진 값을 연결 리스트의 끝에 추가합니다.
- `remove(value)` - 주어진 값을 찾아서 연결을 해제(삭제)합니다
- `getNodeAt(index)` - 주어진 인덱스의 노드를 찾아서 반환합니다. 값이 아니라 노드를 반환해야 하는 것에 주의하세요. 해당 인덱스에 노드가 없다면 undefined를 반환합니다.
- `contains(value)` - 연결리스트에 주어진 값을 가지는 노드의 존재 여부를 반환합니다.
- `indexOf(value)` - 주어진 값의 인덱스를 반환합니다. 없을 경우 -1을 반환합니다.

```jsx
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this._size = 0;
  }

  addToTail(value) {
    const newNode = new Node(value);

    if (this.head === null) {
      this.head = newNode;
      this.tail = newNode;
    } else {
      this.tail.next = newNode;
      this.tail = newNode;
    }

    this._size += 1;
  }

  remove(value) {
    const index = this.indexOf(value);
    if (index === -1) {
      return;
    }

    if (index === 0) {
      if (this.head === this.tail) {
        this.head = null;
        this.tail = null;
        this._size = 0;
      } else {
        this.head = this.head.next;
        this._size -= 1;
      }

      return;
    }

    const prevNode = this.getNodeAt(index - 1);
    const removedNode = prevNode.next;

    if (removedNode === this.tail) {
      prevNode.next = null;
      this.tail = prevNode;
      this._size -= 1;
      return;
    }

    prevNode.next = removedNode.next;
    this._size -= 1;
  }

  getNodeAt(index) {
    let counter = -1;

    let currentNode = this.head;
    while (currentNode) {
      counter += 1;
      if (index === counter) {
        return currentNode;
      }
      currentNode = currentNode.next;
    }

    return undefined;
  }

  contains(value) {
    return this.indexOf(value) !== -1;
  }

  indexOf(value) {
    let index = 0;

    let currentNode = this.head;
    while (currentNode) {
      if (currentNode.value === value) {
        return index;
      }
      index += 1;
      currentNode = currentNode.next;
    }

    return -1;
  }

  size() {
    return this._size;
  }
}

module.exports = LinkedList;
```

## 추가개념 
Doubly Linked List

![Untitled (9)](https://user-images.githubusercontent.com/64571546/103385096-62a47c80-4b3c-11eb-9aaf-0372a2402677.png)

이중연결리스트는 단일연결리스트에 포인터가 하나 더 있다는점에서 다르다.

이전노드를 가리키는 포인터, 다음 노드를 가리키는 포인터들을 통해서 양방향으로 순환할 수 있다.

이전노드로 갈수있어서 좋긴하지만 그만큼 메모리 공간도 조금 더 차지한다. 

### Garbage Collection

가비지컬렉션은 간단하게 보면 '쓰레기처리' 다.

가비지란 '정리되지 않은 메모리', '유효하지 않은 메모리 주소'를 말하고, 가비지커렉터는 '메모리 해제'를 시키는 프로그램이다. 

자바스크립트에서 가비지컬렉션은 아무도 참조하지 않은 메모리를 제거한다.
