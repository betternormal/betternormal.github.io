연결리스트는 배열처럼 여러 데이터를 선형적으로 담을 수 있다.

하지만 배열과는 어떤 부분이 다른지도 알아봐야 한다.

해시테이블은 어렵고 다른성격을 가지는 자료구조이지만 장점이 많다.

![Untitled (7)](https://user-images.githubusercontent.com/64571546/103385080-56b8ba80-4b3c-11eb-9966-c929d23fb98f.png)

# 1. 연결리스트

앞에서 다룬 스택이나 큐를 생각해보면 자료구조 내의 데이터가 다른 데이터와 관계성을 가지고 있지는 않았다. 하지만 연결리스트는 다르다. 이름에서도 유추할 수 있듯, 연결리스트의 핵심은 연결(Link)다.

연결리스트는 크기가 동적인 자료구조로 자료구조를 구성하는 요소(노드)의 연결로 이루어져있다. 연결리스트의 어떠한 임의의 지점에 데이터의 추가와 삭제를 할 경우 O(1) (상수시간)의 시간복잡도를 갖는다. 추가와 삭제에 대해 O(n)의 시간복잡도를 갖는 배열과 다르다.

다만 이 추가와 삭제속도에 대한 대가로, 연결리스트의 각 노드는 인덱스를 갖지 않는다. 그래서 어떤 특정데이터를 연결리스트에서 검색하고자 하는 경우 처음부터 전체 연결리스트를 훓어야 하면 이는 O(n)의 시작복잡도를 필요로 한다.

사용예시 

음악을 들을 때 보통 플레이리스트로 듣고싶은 음악을 특정 순서대로 듣는다. 셔플로 섞어서 들을 수도 있지만 항상 한곡씩 듣게 되어있다. 그리고 노래 한곡이 끝나면 다음곡으로 넘어간다. 

연결리스트도 마찬가지로 하나씩 순환된다. 다만 곡 대신 '노드'를 활용한다.

![Untitled (8)](https://user-images.githubusercontent.com/64571546/103385088-5c160500-4b3c-11eb-93ea-76f2018abfd2.png)

구조: 연결리스트에 속한 각 엘리먼트들을 노드(node)라고 부르는데 하나의 노드는 데이터파트(Data Part)와 넥스트파트(Next Part) 두부분으로 이루어져있다.데이터파트에는 값이 저장되어있고, 넥스트 파트는 다음 노드를 가리키고 연결하는 역할을 한다.

![_2020-12-23__7 35 46](https://user-images.githubusercontent.com/64571546/103385092-5fa98c00-4b3c-11eb-88c9-a31b02051792.png)

[Linked List](https://en.wikipedia.org/wiki/Linked_list)

- `addToTail(value)` - 주어진 값을 연결 리스트의 끝에 추가합니다.
- `remove(value)` - 주어진 값을 찾아서 연결을 해제(삭제)합니다
- `getNodeAt(index)` - 주어진 인덱스의 노드를 찾아서 반환합니다. 값이 아니라 노드를 반환해야 하는 것에 주의하세요. 해당 인덱스에 노드가 없다면 undefined를 반환합니다.
- `contains(value)` - 연결리스트에 주어진 값을 가지는 노드의 존재 여부를 반환합니다.
- `indexOf(value)` - 주어진 값의 인덱스를 반환합니다. 없을 경우 -1을 반환합니다.

```jsx
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this._size = 0;
  }

  addToTail(value) {
    const newNode = new Node(value);

    if (this.head === null) {
      this.head = newNode;
      this.tail = newNode;
    } else {
      this.tail.next = newNode;
      this.tail = newNode;
    }

    this._size += 1;
  }

  remove(value) {
    const index = this.indexOf(value);
    if (index === -1) {
      return;
    }

    if (index === 0) {
      if (this.head === this.tail) {
        this.head = null;
        this.tail = null;
        this._size = 0;
      } else {
        this.head = this.head.next;
        this._size -= 1;
      }

      return;
    }

    const prevNode = this.getNodeAt(index - 1);
    const removedNode = prevNode.next;

    if (removedNode === this.tail) {
      prevNode.next = null;
      this.tail = prevNode;
      this._size -= 1;
      return;
    }

    prevNode.next = removedNode.next;
    this._size -= 1;
  }

  getNodeAt(index) {
    let counter = -1;

    let currentNode = this.head;
    while (currentNode) {
      counter += 1;
      if (index === counter) {
        return currentNode;
      }
      currentNode = currentNode.next;
    }

    return undefined;
  }

  contains(value) {
    return this.indexOf(value) !== -1;
  }

  indexOf(value) {
    let index = 0;

    let currentNode = this.head;
    while (currentNode) {
      if (currentNode.value === value) {
        return index;
      }
      index += 1;
      currentNode = currentNode.next;
    }

    return -1;
  }

  size() {
    return this._size;
  }
}

module.exports = LinkedList;
```

## 추가개념 
Doubly Linked List

![Untitled (9)](https://user-images.githubusercontent.com/64571546/103385096-62a47c80-4b3c-11eb-9aaf-0372a2402677.png)

이중연결리스트는 단일연결리스트에 포인터가 하나 더 있다는점에서 다르다.

이전노드를 가리키는 포인터, 다음 노드를 가리키는 포인터들을 통해서 양방향으로 순환할 수 있다.

이전노드로 갈수있어서 좋긴하지만 그만큼 메모리 공간도 조금 더 차지한다. 

### Garbage Collection

가비지컬렉션은 간단하게 보면 '쓰레기처리' 다.

가비지란 '정리되지 않은 메모리', '유효하지 않은 메모리 주소'를 말하고, 가비지커렉터는 '메모리 해제'를 시키는 프로그램이다. 

자바스크립트에서 가비지컬렉션은 아무도 참조하지 않은 메모리를 제거한다.

# 2. Hash Table

해시테이블은 할당된 공간을 이용해 데이터를 저장한다. 데이터는 키(key)와 값(value)으로 받는데, 키값을 해시함수(hash function)에 넣어 반환받은 해시값(hash value)을 이용해 저장할 위치를 정한다.

해시테이블은 도서관에서도 비슷하게 사용한다.

도서관에 가면 책마다 바코드나 고유번호가 있다. 그 고유번호를 이용해 책의 위치라던가 분류, 누가 빌렸는지 등의 정보를 찾을수 있다.

고유번호를 만들 때 특정 규칙들을 이용해서 번호를 만들어내는 과정이 해시함수이다.

### 개념소개

유한한 세상에서는 자원을 얼마나 효율적으로 활용하느냐가 중요하다.

고로 해시테이블을 만들 때 가장먼저 생각해야하는 부분중 하나가 공간할당이다.

하지만 생각보다 메모리를 할당하는것은 쉽지않다. 일단 저장하고싶은 요소들을 다 저장할수 있을만큼 커야한다.또한 저장된 요소들이 별로 없을 때에는 메모리를덜 사용할수 있도록 설계되면 좋다.

아래 예시는 10개의 값을 저장할 수 있는 해시테이블이다.

![Untitled (10)](https://user-images.githubusercontent.com/64571546/103440402-72c97280-4c88-11eb-88a7-e624403f9da6.png)

## 해시테이블에 자료넣기

- 해싱(Hasing)이란 데이터 관리를 위해, 다양한 길이의 데이터를 고정된 형태의 데이터로 매핑(Mapping)시키는 작업을 뜻한다.이러한 기능을 구현한 함수를 해시함수 라고 한다.
- 해시테이블에 들어가는 값들은 키(key)와 값(value)로 묶여있다.
- 중요한점은 하나의 값을 하나의 키로 저장한다는 것이다. 다시말해 두개이상의 다른값을 하나의 키로 저장할 수 없다.
- 생김새가 자바스크립트에 있는 객체(Object)와 비슷하다. 객체도 마찬가지로 키와 값을 가지고 있기 때문이다. 하지만 해시테이블은 키를 해시함수를 사용해서 해시값을 만든다는 점이 다르다.



![Untitled (11)](https://user-images.githubusercontent.com/64571546/103440407-778e2680-4c88-11eb-9089-3948d10e2d4c.png)
![Untitled (12)](https://user-images.githubusercontent.com/64571546/103440409-79f08080-4c88-11eb-8e8c-5fad3e3d4d36.png)

### 해시 테이블에 데이터가 담기는 과정

1. 키와 데이터를 해시 테이블에 넣으면, 해시 함수를 통해 key가 해시값으로 매핑이 됩니다.
2. **버킷(bucket)**에, 해시값을 인덱스로 하여 데이터가 담깁니다.

### 해시함수의 특징

```
1. 해시 테이블에서는 주어진 저장소의 크기 만큼의 값(`0`부터 `저장소.length-1`)을 해시값으로 반환해야 합니다.
2. 특정한 키를 받으면, 항상 같은 값을 반환해야 합니다.

    가령 `복숭`을 키로 해시 함수를 호출한다면, 언제든 `01`이라는 해시값을 받아야겠지요?

3. 해시 함수 자체는 어떠한 값도 저장하지 않습니다. 호출 되었을 때, 해시값을 반환하는 역할만 합니다.
```

![_2020-12-23__7 37 11](https://user-images.githubusercontent.com/64571546/103440410-7a891700-4c88-11eb-98fd-7165ecbbb51f.png)

해시 테이블의 치명적인 단점은 **해시 충돌(hash collision)**이 발생할 수도 있다는 것이다.
해시 충돌이란 서로 다른 키를 같은 해시값에 대응시키는 것을 의미한다.
아무리 잘 짜인 해시 함수를 사용한다 하더라도, 해시 충돌이 일어날 위험성이 늘 있으므로 이러한 **충돌을 처리할 방법** 또한 **꼭** 생각해야 한다.

[Hash Table](https://en.wikipedia.org/wiki/Hash_tables)

참고 :

- 자바스크립트의 배열은 크기가 제한되어 있지 않은 동적 배열입니다.
배열의 크기를 제한시키기 위해 기본 배열 대신 `part-2/src/helpers/limitedArray`를 사용
- 해시 테이블을 구현할 땐 해시 함수가 필요하다. `part-2/src/helpers/hashFunction`에 미리 준비되어 있는 해시 함수를 사용

## Methods

- `insert(key, value)` - 주어진 키와 값을 저장합니다. 이미 해당 키가 저장되어 있다면 값을 덮어씌웁니다.
- `retrieve(key)` - 주어진 키에 해당하는 값을 반환합니다. 없다면 undefined를 반환합니다.
- `remove(key)` - 주어진 키에 해당하는 값을 삭제하고 값을 반환합니다. 없다면 undefined를 반환합니다.
- `_resize(newBucketNum)` - 해시 테이블의 스토리지 배열을 newBucketNum으로 리사이징하는 함수입니다. 해시 테이블에 저장된 key-value 쌍이 bucketNum의 75%를 넘는 경우 bucketNum을 2배로 늘리고, 25%보다 작아지는 경우 bucketNum을 절반으로 줄입니다. **리사이징 후 저장되어 있던 값을 전부 다시 해싱을 해주어야 합니다.** 구현 후 HashTable 내부에서 사용하시면 됩니다.

```jsx
const LimitedArray = require('./helpers/limitedArray');
const hashFunction = require('./helpers/hashFunction');
class HashTable {
  constructor() {
    this._itemNum = 0;
    this._bucketNum = 8;
    this._storage = LimitedArray(this._bucketNum);
  }
  insert(key, value) {
    const index = hashFunction(key, this._bucketNum);
    const bucket = this._storage.get(index) || [];
    for (let i = 0; i < bucket.length; i += 1) {
      const tuple = bucket[i];
      if (tuple[0] === key) {
        const oldValue = tuple[1];
        tuple[1] = value;
        return oldValue;
      }
    }
    bucket.push([key, value]);
    this._storage.set(index, bucket);
    this._itemNum += 1;
    if (this._itemNum > this._bucketNum * 0.75) {
      this._resize(this._bucketNum * 2);
    }
    return undefined;
  }
  retrieve(key) {
    const index = hashFunction(key, this._bucketNum);
    const bucket = this._storage.get(index) || [];
    for (let i = 0; i < bucket.length; i += 1) {
      const tuple = bucket[i];
      if (tuple[0] === key) {
        return tuple[1];
      }
    }
    return undefined;
  }
  remove(key) {
    const index = hashFunction(key, this._bucketNum);
    const bucket = this._storage.get(index) || [];
    for (let i = 0; i < bucket.length; i += 1) {
      const tuple = bucket[i];
      if (tuple[0] === key) {
        bucket.splice(i, 1);
        this._itemNum -= 1;
        if (this._itemNum < this._bucketNum * 0.25) {
          this._resize(Math.floor(this._bucketNum / 2));
        }
        return tuple[1];
      }
    }
    return undefined;
  }
  _resize(newBucketNum) {
    const oldStorage = this._storage;
    // min size of 8, return if nothing to do!
    newBucketNum = Math.max(newBucketNum, 8);
    if (newBucketNum === this._bucketNum) {
      return;
    }
    this._bucketNum = newBucketNum;
    this._storage = LimitedArray(this._bucketNum);
    this._itemNum = 0;
    oldStorage.each((bucket) => {
      if (!bucket) {
        return;
      }
      for (let i = 0; i < bucket.length; i += 1) {
        const tuple = bucket[i];
        this.insert(tuple[0], tuple[1]);
      }
    });
  }
}
module.exports = HashTable;
```
